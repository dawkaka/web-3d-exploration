import Head from 'next/head'
import { Inter } from 'next/font/google'
import styles from '@/styles/Home.module.css'
import Primitives from "@/components/threejs-primitives"
import SceneGraph from "@/components/scenegraph"
import { useEffect, useRef } from "react"
import * as THREE from "three"
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'


const inter = Inter({ subsets: ['latin'] })

export default function Home() {
  return (
    <>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className={`${styles.main} ${inter.className}`} style={{ display: "flex", flexWrap: "wrap", gap: "10px" }}>
        <Primitives />
        <SceneGraph />
        <BuffferGeometry />
      </main>
    </>
  )
}




function BuffferGeometry() {
  const ref = useRef<HTMLCanvasElement>(null)
  const vertices = [
    // front
    // { pos: [-1, -1, 1], norm: [0, 0, 1], uv: [0, 0], },
    // { pos: [1, -1, 1], norm: [0, 0, 1], uv: [1, 0], },
    // { pos: [-1, 1, 1], norm: [0, 0, 1], uv: [0, 1], },

    // { pos: [-1, 1, 1], norm: [0, 0, 1], uv: [0, 1], },
    // { pos: [1, -1, 1], norm: [0, 0, 1], uv: [1, 0], },
    // { pos: [1, 1, 1], norm: [0, 0, 1], uv: [1, 1], },

    // right
    { pos: [1, -1, 1], norm: [1, 0, 0], uv: [0, 0], },
    { pos: [1, -1, -1], norm: [1, 0, 0], uv: [1, 0], },
    { pos: [1, 1, 1], norm: [1, 0, 0], uv: [0, 1], },

    { pos: [1, 1, 1], norm: [1, 0, 0], uv: [0, 1], },
    { pos: [1, -1, -1], norm: [1, 0, 0], uv: [1, 0], },
    { pos: [1, 1, -1], norm: [1, 0, 0], uv: [1, 1], },
    // back

    { pos: [1, -1, -1], norm: [0, 0, -1], uv: [0, 0], },
    { pos: [-1, -1, -1], norm: [0, 0, -1], uv: [1, 0], },
    { pos: [1, 1, -1], norm: [0, 0, -1], uv: [0, 1], },

    { pos: [1, 1, -1], norm: [0, 0, -1], uv: [0, 1], },
    { pos: [-1, -1, -1], norm: [0, 0, -1], uv: [1, 0], },
    { pos: [-1, 1, -1], norm: [0, 0, -1], uv: [1, 1], },


    // left
    { pos: [-1, -1, -1], norm: [-1, 0, 0], uv: [0, 0], },
    { pos: [-1, -1, 1], norm: [-1, 0, 0], uv: [1, 0], },
    { pos: [-1, 1, -1], norm: [-1, 0, 0], uv: [0, 1], },

    { pos: [-1, 1, -1], norm: [-1, 0, 0], uv: [0, 1], },
    { pos: [-1, -1, 1], norm: [-1, 0, 0], uv: [1, 0], },
    { pos: [-1, 1, 1], norm: [-1, 0, 0], uv: [1, 1], },
    // top
    { pos: [1, 1, -1], norm: [0, 1, 0], uv: [0, 0], },
    { pos: [-1, 1, -1], norm: [0, 1, 0], uv: [1, 0], },
    { pos: [1, 1, 1], norm: [0, 1, 0], uv: [0, 1], },

    { pos: [1, 1, 1], norm: [0, 1, 0], uv: [0, 1], },
    { pos: [-1, 1, -1], norm: [0, 1, 0], uv: [1, 0], },
    { pos: [-1, 1, 1], norm: [0, 1, 0], uv: [1, 1], },
    // bottom
    { pos: [1, -1, 1], norm: [0, -1, 0], uv: [0, 0], },
    { pos: [-1, -1, 1], norm: [0, -1, 0], uv: [1, 0], },
    { pos: [1, -1, -1], norm: [0, -1, 0], uv: [0, 1], },

    { pos: [1, -1, -1], norm: [0, -1, 0], uv: [0, 1], },
    { pos: [-1, -1, 1], norm: [0, -1, 0], uv: [1, 0], },
    { pos: [-1, -1, -1], norm: [0, -1, 0], uv: [1, 1], },
  ];

  const positions: number[] = [];
  const normals: number[] = [];
  const uvs: number[] = [];
  for (const vertex of vertices) {
    positions.push(...vertex.pos);
    normals.push(...vertex.norm);
    uvs.push(...vertex.uv);
  }

  const geometry = new THREE.BufferGeometry();
  const positionNumComponents = 3;
  const normalNumComponents = 3;
  const uvNumComponents = 2;
  geometry.setAttribute(
    'position',
    new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
  geometry.setAttribute(
    'normal',
    new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
  geometry.setAttribute(
    'uv',
    new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));


  useEffect(() => {
    const renderer = new THREE.WebGLRenderer({ antialias: true, canvas: ref.current! });

    const fov = 75;
    const aspect = 2;  // the canvas default
    const near = 0.1;
    const far = 100;
    const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    camera.position.z = 5;

    new OrbitControls(camera, renderer.domElement)


    const scene = new THREE.Scene();

    {
      const color = 0xFFFFFF;
      const intensity = 1;
      const light = new THREE.AmbientLight(color, intensity);
      light.position.set(-1, 2, 4);
      scene.add(light);
    }



    const geometry = new THREE.BufferGeometry();
    const positionNumComponents = 3;
    const normalNumComponents = 3;
    const uvNumComponents = 2;
    geometry.setAttribute(
      'position',
      new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
    geometry.setAttribute(
      'normal',
      new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
    geometry.setAttribute(
      'uv',
      new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));

    const loader = new THREE.TextureLoader();
    const texture = loader.load('https://threejs.org/manual/examples/resources/images/star.png');

    function makeInstance(geometry: any, color: number, x: number) {
      const material = new THREE.MeshPhongMaterial({ color, map: texture, side: 2 });
      const cube = new THREE.Mesh(geometry, material);
      scene.add(cube);

      cube.position.x = x;
      return cube;
    }

    const cubes = [
      makeInstance(geometry, 0x88FF88, 0),
      makeInstance(geometry, 0x8888FF, -4),
      makeInstance(geometry, 0xFF8888, 4),
    ];

    function resizeRendererToDisplaySize(renderer: THREE.Renderer) {
      const canvas = renderer.domElement;
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      const needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, false);
      }
      return needResize;
    }

    function render(time: number) {
      time *= 0.001;

      if (resizeRendererToDisplaySize(renderer)) {
        const canvas = renderer.domElement;
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }

      // cubes.forEach((cube, ndx) => {
      //   const speed = 1 + ndx * .1;
      //   const rot = time * speed;
      //   cube.rotation.x = rot;
      //   cube.rotation.y = rot;
      // });

      renderer.render(scene, camera);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  }, [])

  return (
    <canvas ref={ref} style={{ width: "600px", height: "300px" }}></canvas>
  )
}