import Head from 'next/head'
import { Inter } from 'next/font/google'
import styles from '@/styles/Home.module.css'
import Primitives from "@/components/threejs-primitives"
import SceneGraph from "@/components/scenegraph"
import { useEffect, useRef } from "react"
import * as THREE from "three"
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'


const inter = Inter({ subsets: ['latin'] })

export default function Home() {
  return (
    <>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className={`${styles.main} ${inter.className}`} style={{ display: "flex", flexWrap: "wrap", gap: "10px" }}>
        <Primitives />
        <SceneGraph />
        <BuffferGeometry />
        <Shpere />
        <Raycast />
      </main>
    </>
  )
}




function BuffferGeometry() {
  const ref = useRef<HTMLCanvasElement>(null)
  const vertices = [
    // front
    { pos: [-1, -1, 1], norm: [0, 0, 1], uv: [0, 0], },
    { pos: [1, -1, 1], norm: [0, 0, 1], uv: [1, 0], },
    { pos: [-1, 1, 1], norm: [0, 0, 1], uv: [0, 1], },
    { pos: [1, 1, 1], norm: [0, 0, 1], uv: [1, 1], },

    // right
    { pos: [1, -1, 1], norm: [1, 0, 0], uv: [0, 0] },
    { pos: [1, -1, -1], norm: [1, 0, 0], uv: [1, 0] },
    { pos: [1, 1, 1], norm: [1, 0, 0], uv: [0, 1] },
    { pos: [1, 1, -1], norm: [1, 0, 0], uv: [1, 1] },

    // back
    { pos: [1, -1, -1], norm: [0, 0, -1], uv: [0, 0] },
    { pos: [-1, -1, -1], norm: [0, 0, -1], uv: [1, 0] },
    { pos: [1, 1, -1], norm: [0, 0, -1], uv: [0, 1] },
    { pos: [-1, 1, -1], norm: [0, 0, -1], uv: [1, 1] },

    // left
    { pos: [-1, -1, -1], norm: [-1, 0, 0], uv: [0, 0], },
    { pos: [-1, -1, 1], norm: [-1, 0, 0], uv: [1, 0], },
    { pos: [-1, 1, -1], norm: [-1, 0, 0], uv: [0, 1], },
    { pos: [-1, 1, 1], norm: [-1, 0, 0], uv: [1, 1], },

    // top
    { pos: [1, 1, -1], norm: [0, 1, 0], uv: [0, 0], },
    { pos: [-1, 1, -1], norm: [0, 1, 0], uv: [1, 0], },
    { pos: [1, 1, 1], norm: [0, 1, 0], uv: [0, 1], },
    { pos: [-1, 1, 1], norm: [0, 1, 0], uv: [1, 1], },

    // bottom
    { pos: [1, -1, 1], norm: [0, -1, 0], uv: [0, 0], },
    { pos: [-1, -1, 1], norm: [0, -1, 0], uv: [1, 0], },
    { pos: [1, -1, -1], norm: [0, -1, 0], uv: [0, 1], },
    { pos: [-1, -1, -1], norm: [0, -1, 0], uv: [1, 1], },
  ];

  const positions: number[] = [];
  const normals: number[] = [];
  const uvs: number[] = [];
  for (const vertex of vertices) {
    positions.push(...vertex.pos);
    normals.push(...vertex.norm);
    uvs.push(...vertex.uv);
  }

  const geometry = new THREE.BufferGeometry();
  const positionNumComponents = 3;
  const normalNumComponents = 3;
  const uvNumComponents = 2;
  geometry.setAttribute(
    'position',
    new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
  geometry.setAttribute(
    'normal',
    new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
  geometry.setAttribute(
    'uv',
    new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));


  useEffect(() => {
    const renderer = new THREE.WebGLRenderer({ antialias: true, canvas: ref.current! });

    const fov = 75;
    const aspect = 2;  // the canvas default
    const near = 0.1;
    const far = 100;
    const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    camera.position.z = 5;

    new OrbitControls(camera, renderer.domElement)


    const scene = new THREE.Scene();

    {
      const color = 0xFFFFFF;
      const intensity = 1;
      const light = new THREE.AmbientLight(color, intensity);
      light.position.set(-1, 2, 4);
      scene.add(light);
    }

    const geometry = new THREE.BufferGeometry();
    const positionNumComponents = 3;
    const normalNumComponents = 3;
    const uvNumComponents = 2;
    geometry.setAttribute(
      'position',
      new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
    // geometry.setAttribute(
    //   'normal',
    //   new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));

    geometry.setAttribute(
      'uv',
      new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));
    geometry.setIndex([
      0, 1, 2, 2, 1, 3,
      4, 5, 6, 6, 5, 7,
      8, 9, 10, 10, 9, 11,
      12, 13, 14, 14, 13, 15,
      16, 17, 18, 18, 17, 19,
      20, 21, 22, 22, 21, 23
    ])
    geometry.computeVertexNormals()

    const loader = new THREE.TextureLoader();
    const texture = loader.load('https://threejs.org/manual/examples/resources/images/star.png');

    function makeInstance(geometry: any, color: number, x: number) {
      const material = new THREE.MeshPhongMaterial({ color, map: texture, side: 2 });
      const cube = new THREE.Mesh(geometry, material);
      scene.add(cube);

      cube.position.x = x;
      return cube;
    }

    const cubes = [
      makeInstance(geometry, 0x88FF88, 0),
      makeInstance(geometry, 0x8888FF, -4),
      makeInstance(geometry, 0xFF8888, 4),
    ];

    function resizeRendererToDisplaySize(renderer: THREE.Renderer) {
      const canvas = renderer.domElement;
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      const needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, false);
      }
      return needResize;
    }

    function render(time: number) {
      time *= 0.001;

      if (resizeRendererToDisplaySize(renderer)) {
        const canvas = renderer.domElement;
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }


      cubes.forEach((cube, ndx) => {
        const speed = 1 + ndx * .1;
        const rot = time * speed;
        cube.rotation.x = rot;
        cube.rotation.y = rot;
      });

      renderer.render(scene, camera);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  }, [])

  return (
    <canvas ref={ref} style={{ width: "600px", height: "300px" }}></canvas>
  )
}

function Shpere() {
  const ref = useRef<HTMLCanvasElement>(null)
  useEffect(() => {
    const renderer = new THREE.WebGLRenderer({ antialias: true, canvas: ref.current! });

    const fov = 75;
    const aspect = 2;  // the canvas default
    const near = 0.1;
    const far = 100;
    const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    camera.position.z = 5;

    new OrbitControls(camera, renderer.domElement)

    const scene = new THREE.Scene();

    function addLight(x: number, y: number, z: number) {
      const color = 0xFFFFFF;
      const intensity = 1;
      const light = new THREE.DirectionalLight(color, intensity);
      light.position.set(x, y, z);
      scene.add(light);
    }

    addLight(-1, 2, 4);
    addLight(2, -2, 3);

    function makeSphere(segDown: number, segAround: number) {
      let positions = new Float32Array(segDown * segAround * 6 * 3)
      const numComponents = 3
      let indices = []

      const longHelper = new THREE.Object3D();
      const latHelper = new THREE.Object3D();
      const pointHelper = new THREE.Object3D();
      longHelper.add(latHelper);
      latHelper.add(pointHelper);
      pointHelper.position.z = 1;
      const temp = new THREE.Vector3();

      function getPoint(lat: number, long: number) {
        latHelper.rotation.x = lat;
        longHelper.rotation.y = long;
        longHelper.updateMatrixWorld(true);
        return pointHelper.getWorldPosition(temp).toArray();
      }

      let posNdx = 0
      let ndx = 0
      for (let down = 0; down < segDown; down++) {
        const v0 = down / segDown;
        const v1 = (down + 1) / segDown;
        const lat0 = (v0 - 0.5) * Math.PI;
        const lat1 = (v1 - 0.5) * Math.PI;

        for (let across = 0; across < segAround; ++across) {
          const u0 = across / segAround;
          const u1 = (across + 1) / segAround;
          const long0 = u0 * Math.PI * 2;
          const long1 = u1 * Math.PI * 2;

          positions.set(getPoint(lat0, long0), posNdx); posNdx += numComponents;
          positions.set(getPoint(lat1, long0), posNdx); posNdx += numComponents;
          positions.set(getPoint(lat0, long1), posNdx); posNdx += numComponents;
          positions.set(getPoint(lat1, long1), posNdx); posNdx += numComponents;

          indices.push(
            ndx, ndx + 1, ndx + 2,
            ndx + 2, ndx + 1, ndx + 3,
          );
          ndx += 4;
        }
      }
      return { positions, indices }
    }


    const segmentsAround = 24
    const segmentsDown = 16
    const { positions, indices } = makeSphere(segmentsAround, segmentsDown);
    const normals = positions.slice()

    const geometry = new THREE.BufferGeometry();
    const positionNumComponents = 3;
    const normalNumComponents = 3;

    const positionAttribute = new THREE.BufferAttribute(positions, positionNumComponents);
    positionAttribute.setUsage(THREE.DynamicDrawUsage);
    geometry.setAttribute(
      'position',
      positionAttribute);
    geometry.setAttribute(
      'normal',
      new THREE.BufferAttribute(normals, normalNumComponents));
    geometry.setIndex(indices);


    function makeInstance(geometry: any, color: any, x: any) {
      const material = new THREE.MeshPhongMaterial({
        color,
        side: THREE.DoubleSide,
        shininess: 100
      });

      const cube = new THREE.Mesh(geometry, material);
      scene.add(cube);

      cube.position.x = x;
      return cube;
    }

    const cubes = [
      makeInstance(geometry, 0xFF0000, 0),
    ];


    const temp = new THREE.Vector3();

    function render(time: number) {
      time *= 0.001;

      if (resizeRendererToDisplaySize(renderer)) {
        const canvas = renderer.domElement;
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }

      for (let i = 0; i < positions.length; i += 3) {
        const quad = (i / 12 | 0);
        const ringId = quad / segmentsAround | 0;
        const ringQuadId = quad % segmentsAround;
        const ringU = ringQuadId / segmentsAround;
        const angle = ringU * Math.PI * 2;
        temp.fromArray(normals, i);
        temp.multiplyScalar(THREE.MathUtils.lerp(1, 1.4, Math.sin(time + ringId + angle) * .5 + .5));
        temp.toArray(positions, i);
      }

      positionAttribute.needsUpdate = true;
      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  }, [])

  return (
    <canvas ref={ref} style={{ width: "600px", height: "300px" }}></canvas>
  )
}

function resizeRendererToDisplaySize(renderer: THREE.Renderer) {
  const canvas = renderer.domElement;
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  const needResize = canvas.width !== width || canvas.height !== height;
  if (needResize) {
    renderer.setSize(width, height, false);
  }
  return needResize;
}

function Raycast() {
  const canvasRef = useRef<HTMLCanvasElement>(null)

  useEffect(() => {
    const renderer = new THREE.WebGLRenderer({ canvas: canvasRef.current! })
    const scene = new THREE.Scene()

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000)
    camera.position.z = 7
    camera.position.y = 2

    {
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(1, 2, 4);
      scene.add(light);
    }

    const b1 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshPhongMaterial({ color: "red" }))
    scene.add(b1)
    const b2 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshPhongMaterial({ color: "red" }))
    b2.position.x = -2
    const b3 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshPhongMaterial({ color: "red" }))
    b3.position.x = 2
    scene.add(b2, b3)

    const mouse = new THREE.Vector2()

    window.addEventListener("mousemove", (e) => {
      const rect = canvasRef.current!.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    });

    const raycast = new THREE.Raycaster()

    function render() {
      if (resizeRendererToDisplaySize(renderer)) {
        const canvas = renderer.domElement;
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }

      raycast.setFromCamera(mouse, camera)
      const intersects = raycast.intersectObjects([b1, b2, b3])

      if (intersects.length > 0) {

        const target = intersects[0]
        if (target.object instanceof THREE.Mesh) {
          target.object.material.color.set("blue")
        }
      } else {
        b1.material.color.set("red")
        b2.material.color.set("red")
        b3.material.color.set("red")
      }

      renderer.render(scene, camera)
      requestAnimationFrame(render)

    }

    requestAnimationFrame(render)

  }, [])

  return (
    <canvas ref={canvasRef} style={{ width: "600px", height: "300px" }}></canvas>
  )
}